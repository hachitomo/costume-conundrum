/* Declarations for the embedded data files generated by 'dicer'.
 * I mean, dicer generates those files. These declarations are homemade.
 */
 
#ifndef DATA_H
#define DATA_H

// Decalsheet, unlike most resources, decodes into a live model rather than serial data.
// It's irrelevant to us, but Egg enforces a 256-decal limit per image. We'll exploit that and make every decalsheet a fixed length.
struct decal { int id,x,y,w,h; };
extern const struct decal decalsheet_sprites[256];

// Length always 256. Contains physics values indexed by map tile value. 0=vacant, 1=solid, 2=oneway
extern const unsigned char tilesheet_terrain[];
extern const int tilesheet_terrain_length;

// Map cells and annotations.
extern const int map_w;
extern const int map_h;
extern const unsigned char map[]; // map_w*map_h
extern const struct map_poi {
  int x,y;
  int cmd;
  int argv[4];
} map_poiv[];
extern const int map_poic;

// Verbatim data tiles. PNG or mp3 or whatever, for shovelling into Raylib's decoders.
extern const unsigned char image_sky[];
extern const int           image_sky_length;
extern const unsigned char image_terrain[];
extern const int           image_terrain_length;
extern const unsigned char image_sprites[];
extern const int           image_sprites_length;
extern const unsigned char image_test[];
extern const int           image_test_length;

// Symbols for map_poiv.
#define CMD_SPRITE 1

// CMD_SPRITE, argv[0]=type
#define SPRITE_HERO 1
#define SPRITE_GHOST 2
#define SPRITE_PRINCESS 3
#define SPRITE_PUMPKIN 4
#define SPRITE_ROBOT 5
#define SPRITE_CLOWN 6

#endif
